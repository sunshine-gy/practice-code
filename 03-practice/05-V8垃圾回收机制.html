<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    首先，对于栈中的垃圾回收主要通过向下移动ESP指针来销毁函数保存在栈中的执行上下文
    
    V8垃圾回收机制主要对于堆(堆中存放的是引用类型)中的数据，具体流程如下：

    1.在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

    2.新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。副垃圾回收器，主要负责新生代的垃圾回收。
    主垃圾回收器，主要负责老生代的垃圾回收。

    3.新生代中用Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，
    一半是空闲区域,新加入的对象会放在对象区域，当对象区域快要写满时，会执行一次垃圾清理操作。
    3.1.首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶
    段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排
    列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存
    碎片了。
    3.2.完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原
    来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操
    作还能让新生代中的这两块区域无限重复使用下去。

    4.主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。
    4.1.首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历
    过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
    4.2.不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致
    大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），让所
    有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

    补充：
    1.一旦执行垃圾回收算法，都需要将正在执行的JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。
    我们把这种行为叫做全停顿（Stop-The-World）。
    2.为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和
     JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。
</body>
</html>