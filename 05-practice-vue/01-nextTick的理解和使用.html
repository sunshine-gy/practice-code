<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    vue 和 react 区别：
    相同点：
    1，都是用了Virtual DOM。
    2，都提供了响应式和组件化的视图组件。
    3，都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关库。 
    不同点：
    1，React中，当某组件的状态发生改变时，它会以该组件为根，重新渲染整个组件子树，而在Vue中，组件的依赖是在渲染的过程中
    自动追踪的，所以系统能准确知晓哪个组件确实需要被重新渲染。
    2，Vue的路由库和状态管理库都由官方维护支持且与核心库同步更新，而React选择把这些问题交给社区维护，因此生态更丰富。
    3，vue 提供了 v-if， v-for等便捷指令，而 React 的jsx功能很强大，扩展性极强。
    4，diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。
       Vue 使用双向指针，边对比，边更新DOM。

    使用 vue 中遇到的坑： 

    遇到最大的坑：vue在用v-if v-else渲染两个相同的按钮，一个绑定了事件，另外一个没有绑定事件。当渲染状态切换的时候，
    会导致未绑定事件的按钮也绑定上了事件。原因是有的vue版本在没给条件渲染的元素加上key标识时候会默认复用元素提升渲染能力，
    导致事件被错误的绑定上另一个按钮。解决方案：更换高版本vue，加上key标识两个按钮。
    
    什么是Vue.nextTick()？
    定义：是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数

    原理：原理就是使用宏任务或微任务来完成事件调用的机制，让自己的回调事件在一个eventLoop的最后执行。
    宏任务或微任务根据浏览器情况采取不同的api，常见的 macro task 有 setTimeout、MessageChannel、
    postMessage、setImmediate；常见的 micro task 有 MutationObserver 和 Promise.then。由于兼容问题，
    需要采取降级策略，再取决于使用哪个api，在通俗一点 ，你可以吧nextTick想象成为setTimeout 
    你就是要把这个事件放到本次事件的循环末尾调用。

    补充：异步回调的概念(两种)：
    1.是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。
    2.执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。
</body>
</html>