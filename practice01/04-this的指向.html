<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- this指向的基本思路：
    1.优先级问题：new绑定>显示绑定(bind)>隐式绑定>默认绑定
    2.箭头函数问题：箭头函数不绑定this指向，所以会不断的往上层作用域找,并且只看上层作用域，即再使用显示绑定也改变不了this的指向
    3.函数中返回一个函数，其this指向为返回函数中的this指向，与绑定的值无关 -->

    <script>
      // 面试题1
      var name = "window";
      var person = {
        name: "person",
        sayName: function () {
          console.log(this.name);
        },
      };
      function sayName() {
        var sss = person.sayName;
        sss(); //window 独立函数调用，没有和对象相关联
        person.sayName(); //person
        (person.sayName)(); //person
        (b = person.sayName)(); //window
      }
      sayName();
      console.log('---------------------------------');

      //面试题2
      var name = "window";
      var person1 = {
        name: "person1",
        foo1: function () {
          console.log(this.name);
        },
        foo2: () => console.log(this.name),
        foo3: function () {
          return function () {
            console.log(this.name);
          };
        },
        foo4: function () {
          return () => {
            console.log(this.name);
          };
        },
      };
      var person2 = { name: "person2" };

      person1.foo1(); //person1
      person1.foo1.call(person2); //person2

      person1.foo2(); //window
      person1.foo2.call(person2); //window

      person1.foo3()(); //window 返回的函数是在全局作用域下的
      person1.foo3.call(person2)(); //window 拿到foo3函数绑定person2，但返回的函数仍是在全局作用域下的
      person1.foo3().call(person2); //person2 拿到foo3函数的返回函数再绑定person2

      person1.foo4()(); //person1 会往上级作用域找
      person1.foo4.call(person2)(); //person2 箭头函数只看上级作用域
      person1.foo4().call(person2); //person1 箭头函数只看上级作用域
    </script>
  </body>
</html>
